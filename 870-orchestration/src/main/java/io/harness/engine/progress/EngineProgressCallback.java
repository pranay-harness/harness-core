package io.harness.engine.progress;

import io.harness.engine.executions.node.NodeExecutionService;
import io.harness.execution.NodeExecution;
import io.harness.execution.NodeExecution.NodeExecutionKeys;
import io.harness.serializer.KryoSerializer;
import io.harness.tasks.BinaryResponseData;
import io.harness.tasks.ProgressData;
import io.harness.waiter.ProgressCallback;

import com.google.inject.Inject;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import lombok.Builder;
import lombok.Value;

@Value
@Builder
public class EngineProgressCallback implements ProgressCallback {
  @Inject NodeExecutionService nodeExecutionService;
  @Inject KryoSerializer kryoSerializer;

  String nodeExecutionId;

  @Override
  public void notify(String correlationId, ProgressData progressData) {
    // TODO (prashant) : Do some thing better here right now to maintain backward compatibility.
    ProgressData data = null;
    if (progressData instanceof BinaryResponseData) {
      data = (ProgressData) kryoSerializer.asInflatedObject(((BinaryResponseData) progressData).getData());
    } else {
      data = progressData;
    }
    NodeExecution nodeExecution = nodeExecutionService.get(nodeExecutionId);

    Map<String, List<ProgressData>> progressDataMap = nodeExecution.getProgressDataMap();
    if (progressDataMap == null) {
      progressDataMap = new LinkedHashMap<>();
    }
    progressDataMap.put(correlationId, Collections.singletonList(data));

    Map<String, List<ProgressData>> finalProgressDataMap = progressDataMap;
    nodeExecutionService.update(
        nodeExecutionId, ops -> { ops.set(NodeExecutionKeys.progressDataMap, finalProgressDataMap); });
  }
}
