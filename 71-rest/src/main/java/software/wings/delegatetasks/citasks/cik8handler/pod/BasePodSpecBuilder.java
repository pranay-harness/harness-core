package software.wings.delegatetasks.citasks.cik8handler.pod;

/**
 * An abstract class to generate K8 pod spec based on parameters provided to it. It builds a minimal pod spec essential
 * for creating a pod. This class can be extended to generate a generic pod spec.
 */

import com.google.inject.Inject;

import io.fabric8.kubernetes.api.model.Container;
import io.fabric8.kubernetes.api.model.EmptyDirVolumeSourceBuilder;
import io.fabric8.kubernetes.api.model.LocalObjectReference;
import io.fabric8.kubernetes.api.model.PodBuilder;
import io.fabric8.kubernetes.api.model.PodFluent;
import io.fabric8.kubernetes.api.model.Volume;
import io.fabric8.kubernetes.api.model.VolumeBuilder;
import software.wings.beans.ci.pod.ContainerParams;
import software.wings.beans.ci.pod.PodParams;
import software.wings.delegatetasks.citasks.cik8handler.container.ContainerSpecBuilder;
import software.wings.delegatetasks.citasks.cik8handler.container.ContainerSpecBuilderResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public abstract class BasePodSpecBuilder {
  @Inject private ContainerSpecBuilder containerSpecBuilder;

  public PodBuilder createSpec(PodParams<ContainerParams> podParams) {
    PodFluent.SpecNested<PodBuilder> podBuilderSpecNested = getBaseSpec(podParams);
    decorateSpec(podParams, podBuilderSpecNested);
    return podBuilderSpecNested.endSpec();
  }

  /**
   * Builds on minimal pod spec generated by getBaseSpec method.
   */
  protected abstract void decorateSpec(
      PodParams<ContainerParams> podParams, PodFluent.SpecNested<PodBuilder> podBuilderSpecNested);

  private PodFluent.SpecNested<PodBuilder> getBaseSpec(PodParams<ContainerParams> podParams) {
    List<LocalObjectReference> imageSecrets = new ArrayList<>();

    Set<String> volumesToCreate = new HashSet<>();
    Map<String, LocalObjectReference> imageSecretByName = new HashMap<>();
    List<Container> containers = getContainers(podParams.getContainerParamsList(), volumesToCreate, imageSecretByName);
    List<Container> initContainers =
        getContainers(podParams.getInitContainerParamsList(), volumesToCreate, imageSecretByName);

    imageSecretByName.forEach((imageName, imageSecret) -> imageSecrets.add(imageSecret));

    List<Volume> volumes = new ArrayList<>();
    volumesToCreate.forEach(volumeName
        -> volumes.add(
            new VolumeBuilder().withName(volumeName).withEmptyDir(new EmptyDirVolumeSourceBuilder().build()).build()));

    return new PodBuilder()
        .withNewMetadata()
        .withName(podParams.getName())
        .withLabels(podParams.getLabels())
        .withNamespace(podParams.getNamespace())
        .endMetadata()
        .withNewSpec()
        .withContainers(containers)
        .withInitContainers(initContainers)
        .withImagePullSecrets(imageSecrets)
        .withVolumes(volumes);
  }

  private List<Container> getContainers(List<ContainerParams> containerParamsList, Set<String> volumesToCreate,
      Map<String, LocalObjectReference> imageSecretByName) {
    List<Container> containers = new ArrayList<>();
    if (containerParamsList == null) {
      return containers;
    }

    for (ContainerParams containerParams : containerParamsList) {
      if (containerParams.getVolumeToMountPath() != null) {
        containerParams.getVolumeToMountPath().forEach(
            (volumeName, volumeMountPath) -> volumesToCreate.add(volumeName));
      }

      ContainerSpecBuilderResponse containerSpecBuilderResponse = containerSpecBuilder.createSpec(containerParams);
      containers.add(containerSpecBuilderResponse.getContainerBuilder().build());
      if (containerSpecBuilderResponse.getImageSecret() != null) {
        LocalObjectReference imageSecret = containerSpecBuilderResponse.getImageSecret();
        imageSecretByName.put(imageSecret.getName(), imageSecret);
      }
    }
    return containers;
  }
}
