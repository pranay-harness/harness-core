directive @dataFetcher(name: String!, contextFieldArgsMap: String, batchLoader: String) on FIELD_DEFINITION

schema {
  query: Query
}

# Harness GraphQL SDL details
type Query {
  # Get details about an application
  application(applicationId: String!): Application @dataFetcher(name: "application")

  #Asking accountID temporarily because there is no auth support as of now.
  #Will remove it once authentication is available
  applications(accountId: String!, limit: Int!, offset: Int): ApplicationConnection
    @dataFetcher(name: "applicationConnection")

  # Get details about an environment
  environment(environmentId: String!): Environment @dataFetcher(name: "environment")

  # Get page data of environments
  environments(applicationId: String!, limit: Int!, offset: Int): EnvironmentConnection
    @dataFetcher(name: "environmentConnection")

  # Get a pipeline object by id
  pipeline(pipelineId: String!): Pipeline @dataFetcher(name: "pipeline")

  pipelines(applicationId: String!, limit: Int!, offset: Int): PipelineConnection
    @dataFetcher(name: "pipelineConnection")

  # Get workflow object by id
  workflow(workflowId: String!): Workflow @dataFetcher(name: "workflow")

  # Get list of workflows for an applicationId. It will return paginated data
  workflows(applicationId: String!, limit: Int!, offset: Int): WorkflowConnection
    @dataFetcher(name: "workflowConnection")

  # Get the execution status of a workflow
  execution(executionId: String!): Execution @dataFetcher(name: "execution")

  # Get the list of executions.
  executionsByApplication(applicationId: String!, limit: Int!, offset: Int): ExecutionConnection
    @dataFetcher(name: "executionConnection")
  executionsByWorkflow(workflowId: String!, limit: Int!, offset: Int): ExecutionConnection
    @dataFetcher(name: "executionConnection")
  executionsByPipeline(pipelineId: String!, limit: Int!, offset: Int): ExecutionConnection
    @dataFetcher(name: "executionConnection")

  # Get list of successfully deployed articacts.
  deployedArtifacts(applicationId: String!, environmentId: String!, serviceId: String!): [Artifact]
    @dataFetcher(name: "artifact")

  # Get count of instances in your application
  # Taking accountId as input temporarily since there is no auth support as of now.
  instanceCount(accountId: String!, instanceCountType: InstanceCountType = TOTAL): InstanceCount
    @dataFetcher(name: "instanceCount")

  instancesByService(serviceId: String, limit: Int!, offset: Int): InstanceConnection
    @dataFetcher(name: "instancesByService")

  instancesByEnvironment(environmentId: String, limit: Int!, offset: Int): InstanceConnection
    @dataFetcher(name: "instancesByEnvironment")

  #Adding accountId as input temporarily since there is no auth support as of now
  instancesByEnvironmentType(accountId: String!, envType: EnvironmentType, limit: Int, offset: Int): InstanceConnection
    @dataFetcher(name: "instancesByEnvType")

  # Get details about a service
  service(serviceId: String!): Service @dataFetcher(name: "service")

  # Get list of services for applicationId. It will return paginated data
  services(applicationId: String!, limit: Int!, offset: Int): ServiceConnection @dataFetcher(name: "serviceConnection")
}

# DateTime which will return date based on PST zone
scalar DateTime
scalar Object

type PageInfo {
  hasMore: Boolean
  total: Int
  offset: Int
  limit: Int
}

# Type for pipeline
type Pipeline {
  # Pipeline Id
  id: String

  # Name of the pipeline
  name: String

  # Description of the pipeline
  description: String
}

type PipelineConnection {
  pageInfo: PageInfo
  nodes: [Pipeline]
}

# Type workflow
type Workflow {
  # Workflow Id
  id: String

  # Name of the workflow
  name: String

  # Description of the workflow
  description: String
}

type WorkflowConnection {
  pageInfo: PageInfo
  nodes: [Workflow]
}

enum ExecutionStatus {
  ABORTED
  ERROR
  FAILED
  PAUSED
  QUEUED
  RESUMED
  RUNNING
  SUCCESS
  WAITING
  SKIPPED
  REJECTED
  EXPIRED
}

interface Execution {
  id: String
  queuedTime: DateTime
  startTime: DateTime
  endTime: DateTime
  status: ExecutionStatus
}

type ExecutionConnection {
  pageInfo: PageInfo
  nodes: [Execution]
}

# Type for workflow execution
type WorkflowExecution implements Execution {
  # Workflow Execution Id
  id: String

  # DateTime when execution started
  queuedTime: DateTime

  # DateTime when execution started
  startTime: DateTime

  # DateTime when execution ended
  endTime: DateTime

  # Status of the workflow
  status: ExecutionStatus
}

# Type for pipeline execution
type PipelineExecution implements Execution {
  # Workflow Execution Id
  id: String

  # DateTime when execution started
  queuedTime: DateTime

  # DateTime when execution started
  startTime: DateTime

  # DateTime when execution ended
  endTime: DateTime

  # Status of the workflow
  status: ExecutionStatus
}

# Service Type
type Service {
  # Service Id
  id: String
  # Name of the service
  name: String
  # Description of the Service
  description: String
  # Artifact type deployed by this service
  artifactType: String
  # Deployment Type SSH, Helm, Kubernetes
  deploymentType: String

  instances(limit: Int!, offset: Int): InstanceConnection
    @dataFetcher(name: "instancesByService", contextFieldArgsMap: "{ \"serviceId\": \"id\"}")
}

type ServiceConnection {
  pageInfo: PageInfo
  nodes: [Service]
}

# Aritifact type
type Artifact {
  # Artifact Id
  id: String
  # Source of the artifact Docker Jenkins
  sourceName: String
  # Display name of the artifact
  displayName: String
  # Build number of the artifiact
  buildNo: String
  # Workflow that successfully deployed it last
  workflowExecutionName: String
  # Pipeline that successfully deployed it last
  pipelineflowExecutionName: String
  # DateTime when artifact was last successfully last
  lastDeployedAt: DateTime
  # Last User who deployed successfully this artifact
  lastDeployedBy: String
  # Application of the artifact
  application: Application
    @dataFetcher(
      name: "application"
      contextFieldArgsMap: "{ \"applicationId\": \"applicationId\"}"
      batchLoader: "application"
    )
}

type Application {
  id: String
  name: String
  description: String

  services(limit: Int!, offset: Int): ServiceConnection
    @dataFetcher(name: "serviceConnection", contextFieldArgsMap: "{ \"applicationId\": \"id\"}")
}

type ApplicationConnection {
  pageInfo: PageInfo
  nodes: [Application]
}

type Environment {
  id: String
  name: String
  description: String
  type: EnvironmentType
  instances(limit: Int!, offset: Int): InstanceConnection
    @dataFetcher(name: "instancesByEnvironment", contextFieldArgsMap: "{ \"environmentId\": \"id\"}")
}

type EnvironmentConnection {
  pageInfo: PageInfo
  nodes: [Application]
}

enum InstanceType {
  PHYSICAL_HOST_INSTANCE
  EC2_CLOUD_INSTANCE
  GCP_CLOUD_INSTANCE
  ECS_CONTAINER_INSTANCE
  KUBERNETES_CONTAINER_INSTANCE
  PCF_INSTANCE
}

enum EnvironmentType {
  PROD
  NON_PROD
  ALL
}

type InstanceCount {
  count: Int
  instanceCountType: InstanceCountType
}

type Instance {
  id: String
  type: InstanceType
}

type InstanceConnection {
  pageInfo: PageInfo
  nodes: [Instance]
}

enum InstanceCountType {
  TOTAL
  NINETY_FIVE_PERCENTILE
}
