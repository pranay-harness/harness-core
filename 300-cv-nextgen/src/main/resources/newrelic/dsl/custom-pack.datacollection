Var index = 0
Var tempList = []
Var one = 1
Var lengthOfItems = Env:queries.length()
Var requests = []
Var returnList = []
Var emptySpace = ""
Var queryConcat = concat(" SINCE ", Env:startTimeMillis, " UNTIL ", Env:endTimeMillis, " TIMESERIES ")
while Var:index !=  Var:lengthOfItems {
    Var query = Env:queries[Var:index]
    Var metricValuePath = Env:metricJsonPaths[Var:index]
    Var timestampPath = Env:timestampJsonPaths[Var:index]
    Var metricName = Env:metricNames[Var:index]
    Var metricIdentifier =  Env:metricIdentifiers[Var:index]

    Var fullQuery = concat(Env:baseUrl, "query?nrql=", Var:query, Var:queryConcat)

    print Var:fullQuery
    Request metricRequest = new Request(url=Var:fullQuery, header=Env:commonHeaders)
    Var resp = sync-call(url=Var:fullQuery, header=Env:commonHeaders)

    Var metricValArr = extract(Var:resp,Var:metricValuePath)
    Var timestampArr = extract(Var:resp,Var:timestampPath)

    Var nullVal = null
    Var innerIndex = 0
    Var lengthOfResults = Var:metricValArr.length()
    print Var:lengthOfResults

    while Var:innerIndex !=  Var:lengthOfResults {
        Var metricVal = Var:metricValArr[Var:innerIndex]
        Var timestamp = Var:timestampArr[Var:innerIndex]
        if Var:metricVal != Var:nullVal  {
            Var tsRecord = new TimeseriesRecord(txnName=Env:groupName, metricIdentifier=Var:metricIdentifier, metricName=Var:metricName, metricValue=Var:metricVal, timestamp=Var:timestamp)
            Var:returnList.append(Var:tsRecord)
        }
        innerIndex = Var:innerIndex + Var:one
    }

    index = Var:index + Var:one
}
return Var:returnList